{{
let grammerAST = require("./grammerAST");
}}

start
	= mathSeq

mathSeq
	= opt_ws exp:expression (opt_ws @mathOp opt_ws @expression)* opt_ws

mathOp
	= "*"
	/ "/"
	/ "+"
	/ "-"

expression
	= diceroll
	/ parenExpress
	/ intVal

diceroll
	= x:intVal? [dD] min:intVal ".." max:intVal rollModifiers?
	/ x:intVal? [dD] max:intVal rollModifiers?
	/ x:intVal? [wW] min:intVal ".." max:intVal rollModifiers?
	/ x:intVal? [wW] max:intVal rollModifiers?
	/ min:intVal ".." max:intVal rollModifiers?

rollModifiers
	= simpleModifiers
	/ fullModifiers

simpleModifiers
	= ":" [kKdD] [hHlL]? intVal?
	/ ":" [hHlL] intVal?
	/ ":rr" intVal?

fullModifiers
	= opt_ws "{" opt_ws modifierSeq opt_ws "}"

modifierSeq
	= modifier ( opt_ws ";" opt_ws @modifier )*

modifier
	= keepDropModifier
	/ explodeModifier
	/ rerollModifier

keepDropModifier
	= ("keep" / "drop") (need_ws "highest" / need_ws "lowest") (need_ws intVal)?

explodeModifier
	= "explode" (need_ws comparison opt_ws intVal)? (need_ws intVal "x")?

rerollModifier
	= "reroll" opt_ws comparison opt_ws intVal need_ws intVal "x"
	/ "reroll" need_ws intVal need_ws intVal "x"
	/ "reroll" opt_ws comparison opt_ws intVal
	/ "reroll" need_ws intVal "x"
	/ "reroll" need_ws intVal
	/ "reroll"

comparison "comparison operator"
	= ">="
	/ "<="
	/ "!="
	/ [>=<]

parenExpress
	= roundIndicator? rawParens

rawParens
	= "(" opt_ws mathSeq opt_ws ")"

intVal "integer or rounded expression"
	= roundIndicator? variable
	/ roundIndicator rawParens
	/ intLiteral

roundIndicator
	= [cCfFrR]

variable
	= "[" [^\[\]]+ "]"

intLiteral
	= [-]? [0-9]+

opt_ws "whitespace"
	= [\n\r\t ]*

need_ws "required whitespace"
	= [\n\r\t ]+

//// old implemention
/*
start
	= ws r:dicerolls ws { return r; }

dicerolls
	//= head:multiplicationSeq op:additionOp tail:additionSeq { return opAST(op, [v1, v2]) }
	/// out:additionSeq { return out; }
	= out:additionSeq { return out; }
	/ out:parenExpress { return out; }

parenExpress
	= "(" ws rolls:dicerolls ws ")" { return parenAST(rolls) }

multiplicationOp
	= ws "*" ws { return '*'; }
	/ ws "/" ws { return '/'; }

multiplicationSeq
	= multHead:multHead op:multiplicationOp multTail:multiplicationSeq {
		if(multTail.op !== 'mult'){
			multTail = {'op':'mult', 'multiplicants':[['*', multTail]]};
		}
		multTail.multiplicants[0][0] = op;
		multTail.multiplicants.unshift(['*', multHead]);
		return multTail;
		}
	/ d:diceroll { return d; }
	/ paren:parenExpress { return paren; }

multHead
	= diceroll
	/ intval
	/ parenExpress

additionSeq
	= addHead:multiplicationSeq op:additionOp addTail:additionSeq {
		if(addTail.op !== 'sum'){
			addTail = {'op':'sum', 'addends':[['+', addTail]]};
		}
		addTail.addends[0][0] = op;
		addTail.addends.unshift(['+', addHead]);
		return addTail;
	}
	/ op:multiplicationSeq { return op; }
	/ op:parenExpress { return op; }

additionOp
	= ws "+" ws { return "+"; }
	/ ws "-" ws { return "-"; }

diceroll
	= d:diceform ws "{" ws mods:modifiers ws "}" { return diceRollAST(d, mods) }
	/ d:diceform ":" mods:simplifiedMods { return dicerollAST(d, mods) }

diceform
	= x:intval mode:rollmode mm:maybe_minmax { return diceFormObj(x, mode.toLowerCase(), mm); }
	/ mode:rollmode mm:maybe_minmax { return diceFormObj(staticAST(1), mode.toLowerCase(), mm); }
	/ mm:minmax { return diceFormObj(staticAST(1), 'd', mm); }

rollmode
	= [dw]i

maybe_minmax
	= mm:minmax { return mm; }
	/ max:intval { return minMaxObj(staticAST(1), max); }

minmax
	= min:intval ".." max:intval { return minMaxObj(min, max); }

simplifiedMods
	= rr:simpleReroll { return rr; }
	/ dk:simpleDropKeep { return dk; }

simpleReroll
	= [r]i [r]i { return {'op':'modlist', 'args':[{'op':'modifier','type':'reroll', 'args':['min',1]}]}}

simpleDropKeep
	= act:[dk]i? direction:[hl]i? howMany:intval? { return {'op':'modlist', 'args':[{'op':'modifier','type':}]}}

ws
	= [\n\r\t ]*

ws1 "needed whitespace"
	= [\n\r\t ]+

intval "an integer literal, variable name (rounded or not), or rounded parenthesis"
	= i:integer {
		return {'op': 'static', value: i};
	}
	/ l:lookup{
		return l;
	}
	/ f:mathit v:lookup{
		return {'op':f, args:[v]};
	}
	/ f:mathit ex:parenExpress{
		return {'op':f, args:ex.args};
	}

mathit
	= "f" { return 'floor'; }
	/ "r" { return 'round'; }
	/ "c" { return 'ceil'; }

lookup
	= v:variable { return {'op':'lookup', 'value':v}; }

variable
	= "[" varname:[^[\]]+ "]" { return varname.join(""); }

integer "integer"
	= digits:[0-9]+ { return parseInt(digits.join(""), 10); }
	/ "-" digits:[0-9]+ { return parseInt(digits.join(""), 10) * -1; }
	*/
